# OopsyRaidsyトリガーフォーマット

## おっとファイル形式

このディレクトリ内の各ファイルは有効なJavaScriptであるべきとに記載されているべきである **manifest.txt**。

各ファイルは次のようになります。

```javascript
[{
  zoneId：ZoneId.TheUnendingCoilOfBahamutUltimate、
  トリガー：[
    {/ * ..トリガー1.。 * /}、
    {/ * ..トリガー2.。 * /}、
    {/ * ..トリガー3.。 * /}、
  ]
}
{
  するzoneid：ZoneId.TheFinalCoilOfBahamutTurn4、
  トリガ：[
    {/ * ..trigger 1 .. * /}、
    {/ * ..トリガー2.。 * /}、
    {/ * ..トリガー3.。 * /}、
  ]
}]
```

各ファイルは、トリガーセットの配列に評価される必要があります。 トリガ・セットのいずれか有している `するzoneid` 又は `zoneRegex` に、そのトリガのすべてが適用されるべきかどうかのために、現在のゾーンに対する一致。 一連の `するzoneid` の定数から来る [zone_id.js](../resources/zone_id.js)。 `zoneRegex` は、ゾーンの名前 と一致する正規表現であり、ゾーンの指定方法との下位互換性 として引き続き使用できます。 ゾーンが一致する場合、トリガーはそのゾーンで有効になり、それ以外の場合は無視されます。 `トリガー` は、トリガーセット内のトリガーの配列を保持します。 個々のトリガーのそれぞれの形式については、以下を参照してください。

## おっとトリガー形式

各トリガーは、次のフィールドを持つオブジェクトです。  すべてのフィールドはオプションです。

* `id`：トリガーを無効にするために使用する、このトリガーを表す文字列。  参照してください [oopsyraidsy-example.js](../users/oopsyraidsy-example.js)。
* `条件`：このトリガーを実行するかどうかのブール値を返す関数。
* `正規表現`：行全体に一致する正規表現。
* `damageRegex`：のみダメージを与える能力のIDと一致します正規表現。
* `healRegex`：回復能力のIDにのみ一致する正規表現。
* `gainsEffectRegex`：名前でゲイン効果に一致する正規表現。
* `lostEffectRegex`：一致する正規表現は名前による効果を失います。
* `abilityRegex`：能力のいずれかのタイプのIDを一致する正規表現。
* `collectSeconds`：float（またはfloatを返す関数）
* `delaySeconds`：このトリガーを実行する前に待機する時間のfloat（またはfloatを返す関数）。  場合は無視されます `collectSeconds > 0`。
* `deathReason`：プレイヤーがそれ以上ダメージを受けずに死亡した場合、プレイヤーが死亡した理由を無効にします。  これは、Beyond Deathをクリアするのを忘れるなど、明らかなログ行なしであなたを殺すもののためのものです。
* `ミス`：ライブリストに追加する単一のミスまたはミスの配列を返します。  `ミス` フォーマットについては以下を参照してください。
* `実行`：実行するだけで、何も返さない関数

### `間違い` フォーマット

* `タイプ` はアイコンです：引っ張る、警告する、失敗する、ポーション、死ぬ、拭く（:arrow_forward::warning::no_entry_sign::cocktail::skull::toilet:）。
* `name` は、この間違いが発生したときにリストするオプションのフルプレーヤー名です。  これにより、ライブリストで名前が先頭に追加されます。
* `非難` は、この間違いのせいにするオプションの完全なプレーヤー名（または完全なプレーヤー名の配列）です。  `名前` が指定されていない場合、 `名前` は `非難` プレーヤーになります。
* `テキスト` は、間違いのオプションの理由です。  責任のあるプレーヤーの短い名前（存在する場合）が前に付けられます。
* `fullText` が存在する場合は、誰が非難されているかに関係なく、行のテキスト全体になります。

「これが印刷されます:no_entry_sign: ライブログに：ダイナモLatkeを」。

```javascript
間違い：function（event、data、matches）{
  return {
    type: 'fail',
    blame: e.targetName,
    text: 'Dynamo'
  };
}、
```

これは、「印刷します:warning: プレイヤーが非難されたにもかかわらず、ライブログにおっ」と。

```javascript
間違い：function（event、data、matches）{
  return {
    type： 'warn'、
    blame：e.targetName、
    fullText： 'WHOOPS'、
  };
}、
```

### `deathReason` フォーマット

* `名前` は、次の死亡理由を上書きする完全なプレーヤー名です。
* `理由` は使用する文字列です。

この次のトリガーを使用した場合、プレイヤーが他のダメージを受けずに死亡した場合、ログには、このトリガーの前にプレイヤーが受けた最後のダメージに割り当てるのではなく、「:skull: Chippy：Doom Debuff」と表示されます。 「:skull: チッピー：自動（3034/38471）」。

```javascript
deathReason：関数（イベント、データ、マッチ）{
  リターン {
    name: event.targetName,
    reason: 'Doom Debuff',
  }、
}、
```

## Oopsyトリガー関数パラメーター

：oopsyトリガー内のすべての機能は、次の3つのパラメータを取得 `イベント`、 `、データ`、 `試合` この順序で。

### イベントフィールド

トリガーで指定されたすべての関数は、1つまたは複数のイベントオブジェクトを取得します。  このオブジェクトには、トリガーの照合に使用された正規表現のタイプに応じて異なるフィールドがあります。

#### すべてのイベント

* `event.line`：文字列。ログ行全体を表します。

#### エフェクトイベント（gainsEffectRegex、losesEffectRegex）

* `event.targetName`：文字列、ターゲットのフルネーム。
* `event.effectName`：文字列、獲得したバフ名、例：「BeyondDeath」。
* `event.gains`：bool、バフが得られた場合はtrue、バフが失われた場合はfalse。
* `event.attackerName`：文字列、ターゲットにこのバフを与えた攻撃者のフルネーム。
* `event.durationSeconds`：float、このバフが獲得された期間。  バフが失われたかどうかは未定義です。

#### 能力イベント（healRegex、damageRegex、abilityRegex）

* `event.type`：ログ行タイプの16進文字列（例：ヘッドマーカーの場合は「1B」）。
* `event.attackerId`：攻撃者のIDの16進文字列
* `event.attackerName`：文字列、ターゲットのフルネーム。
* `event.targetId`：ターゲットのIDの16進文字列。
* `event.targetName`：文字列、ターゲットのフルネーム。
* `event.flags`：このダメージ値のフラグの16進文字列（詳細については、 **oopsyraidsy.js** コメントを参照してください）。
* `event.damage`：フロート、ダメージ、またはヒール値
* `event.damageStr`：文字列、 `見栄えの良いバージョンevent.damage` with！ と!! 批評家のために。
* `event.targetCurrentHp`：int文字列、この能力の時点でのターゲットの馬力。
* `event.targetMaxHp`：int文字列、この能力の時点でのターゲットの最大馬力。
* `event.targetCurrentMp`：int文字列、この能力の時点でのターゲットのmp。
* `event.targetMaxMp`：int文字列、この能力の時点でのターゲットの最大mp。
* `event.targetCurrentTp`：int文字列、この能力の時点でのターゲットのtp。
* `event.targetMaxTp`：int文字列、この能力の時点でのターゲットの最大tp。
* `event.targetX`：この能力が使用されたときのターゲットのx位置。
* `event.targetY`：この能力が使用されたときのターゲットのy位置。
* `event.targetZ`：この能力が使用されたときのターゲットのz位置。
* `event.attackerX`：この能力が使用されたときの攻撃者のx位置。
* `event.attackerY`：この能力が使用されたときの攻撃者のy位置。
* `event.attackerZ`：この能力が使用されたときの攻撃者のz位置。

`data.IsPlayerId（ID）` に対して使用することができる `attackerId` または `するtargetId` そのIDがプレイヤーを表すかどうかを決定します。

現在のhp / mp / tp値は100％正確ではありません。  ACTはこれらの値を定期的にポーリングするため、HoT / DoTティックが1つ古くなっている可能性があります。  最も重要な考慮事項は、現在のhpを超えるダメージは実際には致命的ではない可能性があり、逆に、現在のhpを下回るダメージは致命的であることが判明する可能性があることです。  2秒後に「敗北しました」というメッセージが表示されるまで知る方法はありません。

### 単一イベントの例

ほとんどの場合、単一のイベントがすべての関数に渡されます。

```javascript
{
  // 26BBは、NaelのIronChariotの能力IDです。
  damageRegex '26BB'、
  間違い：機能（イベント、データ、マッチ）{
    ここ//イベントが単一のイベントオブジェクトである
    にconsole.log（event.targetName）。
  }、
}、
```

### 複数のイベントの例（コレクション）

`collectSeconds` が使用されている場合、トリガーがいずれかの行に一致するとすぐに、 `collectSeconds` を待機し、その最初のトリガーと、その期間中に一致する追加のトリガーを配列として渡します。

`条件` 常に単一のイベントを受け取り、イベントを収集する前にフィルターとして機能します。  `条件` が真でない場合は、ログ行が存在せず、最初の一致とコレクションの両方でイベントがスキップされたかのようになります。

`delaySeconds` 収集する際に呼び出されません。

```javascript
{
  //扶助
  healRegex： 'BA'、
  collectSeconds：0.2、
  ミス：機能（イベント、データ、マッチ）{
    ここ//イベントは、イベントオブジェクトの配列である
    I = 0（VARのために、I < events.length; ++ i）
      console.log（events[i].targetName）;
  }、
}、
```

### データフィールド

`データ` は、戦闘全体にわたって持続し、ワイプ時にリセットされるオブジェクトです。  すべての関数に渡されます。

`データ` は、次のフィールドが事前に入力されています。

* `data.me`：文字列、プレイヤーのキャラクター名。
* `data.job`：文字列、プレーヤーのジョブ（例：WAR）。
* `data.role`：文字列、プレイヤーの仕事の役割：タンク、ヒーラー、dps-近接、dps-範囲、dps-キャスター、クラフト、収集。
* `data.inCombat`：bool、プレイヤーが戦闘中であるとゲームが考えるかどうか。  これは、ACTがプレイヤーが戦闘中であると考えるかどうかとは異なります。
* `data.ShortName`：完全なプレーヤー名を短い名前またはニックネームに変換するヘルパー関数。
* `data.IsPlayerId`：ターゲットまたは攻撃者IDがプレーヤーを表すかどうかをチェックするヘルパー関数（ペットまたは暴徒に対して）。

`データ` は、複数のトリガーにわたって状態を追跡する必要がある場合に、トリガーが状態を格納できる、または格納する必要があるものです。

たとえば、あなたがに保存することができ、プレイヤーが運命かを持っているのマップ、保存したい場合は `data.hasDoom`。  これは、複数のトリガーで使用できます。

```javascript
{
  //同じトリガーでゲインとロスの両方を一致させます。
  gainsEffectRegex： 'Doom'、
  lostEffectRegex： 'Doom'、
  実行：function（e、data）{
    data.hasDoom[e.targetName] = e.gains;
  }、
}、
```

### 一致フィールド

`一致` は、文字通り、このトリガーが一致した正規表現から返される正規表現一致オブジェクトです。  `マッチ[0]` 他のアレイエントリが正規表現（もしあれば）から任意の他の基であると、常に完全一致です。  上記単一のイベントの場合には `マッチ[0] ===「アイアンチャリオット」`。

ただし、 `試合` 任意のグループがある （すべて `正規表現` ヘルパー関数が行う）を、 その後、試合は直接、グループのフィールドになります あなたがのようなものを行うことができます `matches.target`。

## トリガーフィールド評価順序

トリガー内の関数の評価の完全な順序は次のとおりです。

1. 正規表現との一致
1. かどうかを確認 `ID` 無効になっています
1. `状態`
1. `collectSeconds`
1. `delaySeconds` （収集していない場合のみ）
1. （遅延と収集の待機はここで発生します）
1. `間違い`
1. `deathReason`
1. `実行`
