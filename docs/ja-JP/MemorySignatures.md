# メモリ署名とチートエンジンのガイド

メモリ署名は、実行可能ファイル内のメモリ位置を見つけるために使用できる一意のバイナリ文字列 です。

これらの署名を見つけることが可能となる、一貫して ゲームの状態まで見て （例えば、私は戦闘で午前、私の仕事のゲージが、私はどのくらいの敵意をしているんです） ゲームはあなたに、このためのAPIを提供することを拒否した場合でも。

このガイドでは、CheatEngineを使用してそのようなメモリシグネチャを見つける方法を示します。 あなたには、いくつかの基本的なアセンブリ言語、知っていればそれはおそらく便利です いくつかのプログラミングを、そして忍耐の極端なレベルを持っています。

## 目次

* [インストール](#installation)
* [新しいメモリ署名の検索](#finding-new-memory-signatures)
  * [チートエンジンをゲームに接続する](#connect-cheat-engine-to-the-game)
  * [初期メモリ検索](#initial-memory-search)
  * [繰り返しスキャン](#repeated-scans)
  * [閲覧メモリ](#browsing-memory)
  * [アプローチ1：作家を見つける](#approach-1-finding-writers)
  * [アプローチ2：トレース](#approach-2-tracing)
  * [アプローチ3：読者を見つける](#approach-3-finding-readers)
  * [アセンブリコードとポインタ](#assembly-code-and-pointers)
  * [アセンブリから署名を抽出する](#extracting-a-signature-from-assembly)
* [既存のメモリ署名をスキャンする](#scan-for-existing-memory-signatures)

## インストール

インストール [チートエンジンの最新バージョン](https://github.com/cheat-engine/cheat-engine/releases/latest)。 インストーラーは追加のガベージをオンにしようとします なので、これをオフにして、やみくもに[次へ]をクリックしないでください。 ごめんなさい。  それはグロスです。

## 新しいメモリ署名の検索

![チートエンジンのスクリーンショット](images/cheatengine_initial.png)

### チートエンジンをゲームに接続する

ファイナルファンタジーXIVを起動してログインします。

次に、CheatEngineを開きます。 クリックして **ファイル**、 を選択し **を開きプロセス**、 、その後、ファイナルファンタジーXIVを選びます。

トップバーには言うべき **ffxiv_dx11.exe** 、この時点で。

![チートエンジン接続のスクリーンショット](images/cheatengine_connected.png)

### 初期メモリ検索

メモリー内でキャラクターのジョブゲージを探しているとしましょう。 簡単にするために、私たちは戦士であり、獣のゲージを探しているだけだとしましょう。 メモリ内の非常に多くの値がゼロであるため、 は別の初期値から始めましょう。

ゲーム内で戦士に切り替えて し、獣のゲージが80になるまで印象的なダミーをヒットします。

CheatEngineに切り替えます。

![チートエンジンの初期スキャンのスクリーンショット](images/cheatengine_initialscan.png)

80の値（16進数ではない）を入力します。 スキャンタイプは `必要があります<code>正確な値` と `値タイプ` のバイト。 現時点では、ビーストゲージがメモリに何バイトを占めるかはわかりません。 ふるいにかけるオプションがはるかに少ないので、4バイト が必要な場合は便利です。 しかし、私たちはまだその仮定をすることはできません。 また、書き込み可能で実行可能ではないメモリも探しています。

その後、クリック **初めてのスキャン**。

これにより、値80の数百万のメモリロケーションが得られる可能性があります。 素晴らしいスタートです！

![チートエンジンがスクリーンショットを見つけました](images/cheatengine_found.png)

これは、これらすべてのメモリ位置のライブビューです。 変わると赤くなります。 これらのいくつかは、ゲームで何もしなくても変化するちらつきの値です。 あなたはいつもマッシュアップすることができます **次のスキャン** スキャンを繰り返し、それらを排除するために数回。

### 繰り返しスキャン

ゲームでは、落ちた劈開を使用して30の獣ゲージに戻ります。

CheatEngineに戻ります。 **値** を30に変更し** 。 **次のスキャン**クリックし** 。 これにより、メモリ位置の数が大幅に削減されます。</p>

ゲーム 値を変更するこのプロセスを繰り返してから、アドレスの数が少なくなるまで新しい値 を再スキャンします。

![チートエンジンのスキャン後のスクリーンショット](images/cheatengine_postscan.png)

黒のアドレスはヒープアドレスです。 緑のアドレスは [静的アドレス](https://medium.com/@nickteixeira/stack-vs-heap-whats-the-difference-and-why-should-i-care-5abc78da1a88)です。 一般に、静的アドレス 探しているのは、静的アドレス を参照するコードを見つけるのが簡単であり、永続的であるためです。

緑の（静的）アドレスが1つになるまでスキャンを続けます。

アドレス を右クリックし、 **を選択します。選択したアドレスをアドレスリストに追加します**。 これにより、アドレスが下部のリストに表示されます。 この場合、私たちの静的アドレスは `14116E128`。

![チートエンジンのアドレスリストのスクリーンショット](images/cheatengine_addresslist.png)

この例に従っている場合、 あなたが持っている静的アドレスは一致しません。 また、ゲームを再開するたびに異なります。 Windowsが持っているからです [アドレス空間配置のランダム化](https://en.wikipedia.org/wiki/Address_space_layout_randomization) 有効になって、 主にそれが難しく、正確なソート私たちが今やっていることの行うことにします。

これが、コード署名を見つける必要がある理由でもあります。 実行可能ファイルとDLLアドレスがランダム化されなかった場合は、 静的アドレスは、実行するたびに同じになります。

### 閲覧メモリ

アドレスリストから、 追加したばかりのアドレスを右クリックして 、**このメモリ領域を参照*を選択します。

これにより、メモリビューアウィンドウが表示されます。 これには、上部に分解ビューがあり、下部にメモリビューアがあります。 紛らわしいことに、これらは別々の図であり、ある *でない* 彼らは同じウィンドウ内にあるにもかかわらず、一緒に同期。 彼らは、あなたが選択したものは何でも最後のアドレスに同期します **を分解し、このメモリ領域に** または **参照。このメモリ領域を** それぞれに。

![チートエンジンのブラウズメモリのスクリーンショット](images/cheatengine_browsememory.png)

ただし、このスクリーンショットの左上に進値であることがわかります `1E`、 であり、 [進で30](https://www.google.com/search?q=0x1e+in+decimal)。

メモリを参照すると、その周りに他に何があるかを確認できます。 これは、エンティティやプレーヤーのデータなどに特に役立ちます。

仕事のデータについては、近くのメモリにはあまり興味深いものはありません。

### アプローチ1：作家を見つける

ここで、これを参照するコードを見つける必要があります。 これを行う最も簡単な方法は、この値を変更するものを見つけることです。

アドレスリストのアドレス を右クリックし、 **を選択します。このアドレスに何が書き込まれるかを調べます**。 これにより、デバッガーを接続するように求められます。「はい」と言います。 新しいウィンドウがポップアップします。

FFXIVに戻り、ビーストゲージを変更します。 この場合、30から80に激怒します。

Cheat Engine、 戻ると、新しいデバッガウィンドウにいくつかの情報が表示されます。

![チートエンジンデバッガーのスクリーンショット](images/cheatengine_debugger.png)

これは、ビーストゲージのメモリ位置に書き込んだアセンブリです。

必要に応じて、 は **Show disassembler** をクリックして、周囲のコードを表示できます。

![チートエンジンの分解のスクリーンショット](images/cheatengine_disassembly.png)

残念ながら、この場合、 これは2命令の関数呼び出しです。

値を変更している行である `MOV [RCX + 08]、文献`。 本当にアセンブリ言語、知らない が、Googleは、と言われます `のAl` 最後の8ビット `EAX` レジスタ 以前に設定された `movzx EAX、バイトPTR [RDX + 01]` 行。 これは、メモリを書いているラインであることを考えると `[RCX + 08]` 私たちは、気にポインタである が、我々が設定することを呼び出し元のコードを見つける必要がある `RCX`。 このコードは、実行可能ファイルのどこかで非常に異なる可能性があります。

ここにはいくつかの異なるオプションがあります。 ここでの1つのオプションは、 [実行して、呼び出し元のコード](#approach-2-tracing)を見つけることです。 2番目のオプションは、書き込みだけでなく、アドレス</a> を読み取るものを

検討することです。 3番目のオプション（このガイドでは説明していません）は、値 を変更する他のコードパスを見つけて、そのコードパスの署名が簡単かどうかを確認することです。 （たとえば、ジョブを変更すると、値が別の方法で変更される可能性がありますか？）</p> 



### アプローチ2：トレース

純粋な逆アセンブルで十分なコンテキスト情報が得られない場合、 CheatEngineには「ブレークアンドトレース」機能があります。 [ブラウジングメモリ](#browsing-memory) ビューに戻ります。 この機能は、アドレスリストから直接利用することはできません。

その上で右クリック `1E` あなたが気にバイト。 選択 **データブレークポイントの** 、その後 **ブレーク、トレース**。 デフォルトのオプションはすべて問題ありません。 我々はまだ作家を探しているので、 我々は維持されます **書き込みでブレークを** 選択しました。 クリックして **[OK]を**。

これにより、トレーサーウィンドウが表示されます。 ファイナルファンタジーに戻り、獣のゲージを変更するために何かをします。 Cheat Engineがコールスタックを記録しようとすると、ゲームが一時的に中断する可能性があります。 トレーサーウィンドウに戻ります。

![チートエンジントレースのスクリーンショット](images/cheatengine_tracing.png)

Tracerの行をダブルクリックして と、MemoryViewerの逆アセンブリウィンドウがその場所にジャンプします。

この場合、矢印とダブルクリックの拡大 `RET` リターンアセンブリ命令がに戻っまさに私たちがした 解体ウィンドウ内の前で見ています。

`mov rdxをダブルクリックすると、[rsp + 50]` は、前に見ていたコードを呼び出したコード に移動します。

![チートエンジントレース2スクリーンショット](images/cheatengine_tracing2.png)

その行の直前の `コール` は、私たちが見ていたコード への `コール` です。 そこで、我々はセットかを把握する必要があります `RCX`。 それから設定することのように見えます `R9`。 `R9` におけるポインタから間接的に設定されている `R14`。 これは複雑になっています。 それは見つけるために、アセンブリに戻って保持することが可能です 、いくつかのコードを 多分より簡単なアプローチがあります。



### アプローチ3：読者を見つける

値を変更するコード を見つける代わりに、値を読み取るコードを見つけることもできます。

アドレスリストのアドレスを右クリックし、 を選択して **を選択します。このアドレスにアクセスするものを確認します**。

書き込みとは異なり、 コードは常にこのアドレスにアクセスしている可能性があります。 あなたはヒットする必要があります **停止** 場所の収集を停止するボタンを。

![チートエンジンデバッガー2のスクリーンショット](images/cheatengine_debugger2.png)

この場合、このメモリにアクセスしているコードには2つの場所があります。 1つは非常に頻繁に（3000回）ヒットし、もう1つはまれに（152）ヒットします。

逆アセンブルウィンドウ内を見ると、 はるかに大幅な機能のような二番目のルックスは、 ので、1というのを逆アセンブルしてみましょう。

![チートエンジンの分解2スクリーンショット](images/cheatengine_disassembly2.png)

完璧！ これは、トレースで見たコードよりも少し単純に見えます。



### アセンブリコードとポインタ

静的アドレスを探しているので、 プログラムが開始されると、このアドレスは変更されません。 目標は、探しているアドレスを 囲む安定したアセンブリコードのセットを見つけることです。 次に、メモリ内でこのコードを検索して、特定の実行の場所に関係なく、アドレス を取得できます。

このアセンブリコードを読み取ると、読み取るコードは `movzx ebx、byte ptr [rcx + 08]`です。 英語では、メモリ位置にこのルックスであるものの後に8つのバイト `RCX` レジスタは、バイトが見出され、そしてに動くことを要する `EBX` レジスタ。 （movzxの部分は、 [ゼロが](https://www.felixcloutier.com/x86/movzx) この値を拡張することを意味します。これは、私たちが行っていることにあまり関係がありません。）

`rcx`を見ているので、 `rcx`を設定する行が見つかるまで、アセンブリコード を逆方向に調べる必要があります。 あなたはそれを見ることができます `RCX` に設定されます `楽章RCX、[ffxiv_dx11.exe + 1AAE118]` 行。 ことをこの手段 `RCX` どのように設定されているが、その位置でメモリに格納されます。



```assembly
48 8B 0D 23C14201-mov rcx、[ffxiv_dx11.exe + 1AAE118] {（14116E120）}
48 85 C9-test rcx、rcx
74 B8-je ffxiv_dx11.exe + 681FB2
48 8B 05 67C14201-mov rax、[ffxiv_dx11 .exe + 1AAE168] {（21）}
```


具体的には、 `23C14201` 値は、我々が探しているものです。 RIP相対アドレッシングモードについて簡単に説明します。 RIP相対アドレス指定は、オフセットが命令ポインタに相対的であることを意味します。 `RIP` レジスタは命令ポインタレジスタであり、この命令の直後の命令のアドレスが 含まれています。 次の 行（ `テキストrcx、rcx` 行）をダブルクリックすると、このアドレスが何であるかを確認できます。 私の場合は、アドレスがあると言い `13FD41FF5`。 我々は上にあるので、 [リトルエンディアン](https://en.wikipedia.org/wiki/Endianness) システム、 `23C14201` 進整数4バイトである `01 42 C1 23` （バイトが逆）。 </a> 0x0142C123 + 0x13FD41FF5を 加算すると、0x14116E118になります。 あなただけのダブルクリックすると、チートエンジンはまた、あなたのために、この数を計算します 命令自体に。 例えば、上でダブルクリック `MOV RCX` 行は、テキスト生じる `のMOV RCX、[14116E118]`。 したがって、この計算を行う必要はまったくありませんが、それがどのように機能するかを知っておくのは良いことです。</p> 

チートエンジンからのコメントでは、その `MOVはRCX` 行が値を有する `14116E120`。 これは、メモリアドレスことを意味する `14116E118` 値を有する `14116E120`。 スキャンがいたとき、我々は以前に見つかったメモリアドレス `14116E128`。 それは理にかなってて `14116E120 + 08` 読書として、私たちが望む値である のコードは、そのアドレスに8つのバイトが追加されます。

`14116E118` をメモリ領域に手動で追加するか、非常に近いため、獣のゲージに対して 見つけることができます。

![チートエンジンポインターのスクリーンショット](images/cheatengine_pointer.png)

上記のスクリーンショットでは、 小さな円は、獣ゲージ値である `14116E128` 長い円は、ポインタで `14116E118` で ロードするために使用されている `RCX`。 このメモリの閲覧には、以前のコメントを確認し、 でメモリという `14116E118` ポインタが含まれ `000000014116E120`。 （いつものように、リトルエンディアンはバイトを逆にすることを意味します。）



### アセンブリから署名を抽出する

これで、ビーストゲージへのポインタへのポインタを含むアセンブリコードができました。 署名として機能するために、アセンブリコードからいくつかのバイトを選択する必要があります。

良い署名を選ぶには少し芸術があります。 あなたは、常に相対的なポインタのオフセットを無視したいしたい のような `23C14201` 前の値です。 これらのオフセットは実行ごとに同じですが、 が、パッチごとに頻繁に変更されます。 署名を見つけることは非常に苦痛です なので、理想的には、時の試練に耐える何かを見つけたいと思うでしょう。

この場合、bytes列からバイトをコピーし始めましょう は `mov rcx、...` 行から始まります。



```assembly
48 8B 0D 23C14201-mov rcx、[ffxiv_dx11.exe + 1AAE118] {（14116E120）}
48 85 C9-test rcx、rcx
74 B8-je ffxiv_dx11.exe + 681FB2
48 8B 05 67C14201-mov rax、[ffxiv_dx11 .exe + 1AAE168] {（21）}
```


これが私たちに与えます： `48（b）0D 23C14201 48 85 C9 74 B8 48 8B 05 67C14201`

2つの4バイトパターンは両方ともポインタ なので、最後に1つをドロップして、内部のパターンをワイルドカードにします。 cactbotとCheatEngineの両方で、疑問符 を使用してワイルドカードを作成できます。

したがって、最終的な署名がある： `488B0D ???????? 4885C974B8488B05`

気になるポインタを含むアドレスは、疑問符の4バイトです。

この [はcactbot自体](https://github.com/quisquous/cactbot/blob/df176c4feff81bab356a8e5e6e6b453e94626320/CactbotOverlay/FFXIVProcess.cs#L189)で確認できます。

このシグニチャが一意であることを確認するために、既存のメモリシグニチャ</a> に対して スキャンを実行することが重要です。</p> 

次に、プラグインでのプロセスは次のようになります。

* メモリ内でこの署名を検索する
* RIP相対アドレス指定を実際のポインタに変換します（例： `14116E118`）
* そのメモリ位置でポインタを見つけます（例： `14116E120`）
* このポインターはビーストゲージへのポインターです

なぜなら `14116E118` 点を8にバイト先の `14116E120`、 我々だけでも、これは常に真であることを前提にすることができ 、ちょうど私たちは署名で見つけるものに16のバイトを追加します。 これは、少なくともストームブラッド全体に当てはまります。

足。



## 既存のメモリ署名をスキャンする

既存のメモリシグネチャ 場合は、CheatEngineを使用してメモリ内でそれを見つけることもできます。

![チートエンジンの署名スキャンのスクリーンショット](images/cheatengine_signature_scan.png)

別のスキャンを開始します。 今回は、 **値タイプ** をバイト</strong>**配列に設定し、 **を選択します。この配列**検索します。 **Hex** チェックマークをクリックして、前に取得した署名を貼り付けます。 コードを検索しているので、必ず **実行可能** チェックマークをクリックしてください。</p> 

**最初のスキャン**をクリックすると、単一の結果が見つかります。 そのアドレスを右クリックし、[ **このアドレスを逆アセンブルする** ]を選択すると、前に見つけたコードにすぐに戻ります。
